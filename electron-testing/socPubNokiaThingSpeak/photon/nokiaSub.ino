//for ThingSpeak library
#include "ThingSpeak/ThingSpeak.h"

#define PRINT_DEBUG_MESSAGES

unsigned long myChannelNumber = 58084;
const char * myWriteAPIKey = "GKD8N7LMZFDIAXU7";
#ifdef SPARK
  TCPClient client;
#endif

SYSTEM_MODE(SEMI_AUTOMATIC);

#define PIN_POWER A7 //Pin 1 on LCD
#define PIN_SCE   A2 //Pin 3 on LCD
#define PIN_RESET A0 //Pin 4 on LCD
#define PIN_DC    A1 //Pin 5 on LCD
#define PIN_SDIN  A5 //Pin 6 on LCD
#define PIN_SCLK  A3 //Pin 7 on LCD
#define PIN_LED   D0 //Pin 8 on LCD

//The DC pin tells the LCD if we are sending a command or data
#define LCD_COMMAND 0
#define LCD_DATA  1

//You may find a different size screen, but this one is 84 by 48 pixels
#define LCD_X     84
#define LCD_Y     48

//This table contains the hex values that represent pixels
//for a font that is 5 pixels wide and 8 pixels high
static const byte ASCII[][5] = {
  // First 32 characters (0x00-0x19) are ignored. These are
  // non-displayable, control characters.
   {0x00, 0x00, 0x00, 0x00, 0x00} // 0x20
  ,{0x00, 0x00, 0x5f, 0x00, 0x00} // 0x21 !
  ,{0x00, 0x07, 0x00, 0x07, 0x00} // 0x22 "
  ,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 0x23 #
  ,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 0x24 $
  ,{0x23, 0x13, 0x08, 0x64, 0x62} // 0x25 %
  ,{0x36, 0x49, 0x55, 0x22, 0x50} // 0x26 &
  ,{0x00, 0x05, 0x03, 0x00, 0x00} // 0x27 '
  ,{0x00, 0x1c, 0x22, 0x41, 0x00} // 0x28 (
  ,{0x00, 0x41, 0x22, 0x1c, 0x00} // 0x29 )
  ,{0x14, 0x08, 0x3e, 0x08, 0x14} // 0x2a *
  ,{0x08, 0x08, 0x3e, 0x08, 0x08} // 0x2b +
  ,{0x00, 0x50, 0x30, 0x00, 0x00} // 0x2c ,
  ,{0x08, 0x08, 0x08, 0x08, 0x08} // 0x2d -
  ,{0x00, 0x60, 0x60, 0x00, 0x00} // 0x2e .
  ,{0x20, 0x10, 0x08, 0x04, 0x02} // 0x2f /
  ,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 0x30 0
  ,{0x00, 0x42, 0x7f, 0x40, 0x00} // 0x31 1
  ,{0x42, 0x61, 0x51, 0x49, 0x46} // 0x32 2
  ,{0x21, 0x41, 0x45, 0x4b, 0x31} // 0x33 3
  ,{0x18, 0x14, 0x12, 0x7f, 0x10} // 0x34 4
  ,{0x27, 0x45, 0x45, 0x45, 0x39} // 0x35 5
  ,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 0x36 6
  ,{0x01, 0x71, 0x09, 0x05, 0x03} // 0x37 7
  ,{0x36, 0x49, 0x49, 0x49, 0x36} // 0x38 8
  ,{0x06, 0x49, 0x49, 0x29, 0x1e} // 0x39 9
  ,{0x00, 0x36, 0x36, 0x00, 0x00} // 0x3a :
  ,{0x00, 0x56, 0x36, 0x00, 0x00} // 0x3b ;
  ,{0x08, 0x14, 0x22, 0x41, 0x00} // 0x3c <
  ,{0x14, 0x14, 0x14, 0x14, 0x14} // 0x3d =
  ,{0x00, 0x41, 0x22, 0x14, 0x08} // 0x3e >
  ,{0x02, 0x01, 0x51, 0x09, 0x06} // 0x3f ?
  ,{0x32, 0x49, 0x79, 0x41, 0x3e} // 0x40 @
  ,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 0x41 A
  ,{0x7f, 0x49, 0x49, 0x49, 0x36} // 0x42 B
  ,{0x3e, 0x41, 0x41, 0x41, 0x22} // 0x43 C
  ,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 0x44 D
  ,{0x7f, 0x49, 0x49, 0x49, 0x41} // 0x45 E
  ,{0x7f, 0x09, 0x09, 0x09, 0x01} // 0x46 F
  ,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 0x47 G
  ,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 0x48 H
  ,{0x00, 0x41, 0x7f, 0x41, 0x00} // 0x49 I
  ,{0x20, 0x40, 0x41, 0x3f, 0x01} // 0x4a J
  ,{0x7f, 0x08, 0x14, 0x22, 0x41} // 0x4b K
  ,{0x7f, 0x40, 0x40, 0x40, 0x40} // 0x4c L
  ,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 0x4d M
  ,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 0x4e N
  ,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 0x4f O
  ,{0x7f, 0x09, 0x09, 0x09, 0x06} // 0x50 P
  ,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 0x51 Q
  ,{0x7f, 0x09, 0x19, 0x29, 0x46} // 0x52 R
  ,{0x46, 0x49, 0x49, 0x49, 0x31} // 0x53 S
  ,{0x01, 0x01, 0x7f, 0x01, 0x01} // 0x54 T
  ,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 0x55 U
  ,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 0x56 V
  ,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 0x57 W
  ,{0x63, 0x14, 0x08, 0x14, 0x63} // 0x58 X
  ,{0x07, 0x08, 0x70, 0x08, 0x07} // 0x59 Y
  ,{0x61, 0x51, 0x49, 0x45, 0x43} // 0x5a Z
  ,{0x00, 0x7f, 0x41, 0x41, 0x00} // 0x5b [
  ,{0x02, 0x04, 0x08, 0x10, 0x20} // 0x5c "\"
  ,{0x00, 0x41, 0x41, 0x7f, 0x00} // 0x5d ]
  ,{0x04, 0x02, 0x01, 0x02, 0x04} // 0x5e ^
  ,{0x40, 0x40, 0x40, 0x40, 0x40} // 0x5f _
  ,{0x00, 0x01, 0x02, 0x04, 0x00} // 0x60 `
  ,{0x20, 0x54, 0x54, 0x54, 0x78} // 0x61 a
  ,{0x7f, 0x48, 0x44, 0x44, 0x38} // 0x62 b
  ,{0x38, 0x44, 0x44, 0x44, 0x20} // 0x63 c
  ,{0x38, 0x44, 0x44, 0x48, 0x7f} // 0x64 d
  ,{0x38, 0x54, 0x54, 0x54, 0x18} // 0x65 e
  ,{0x08, 0x7e, 0x09, 0x01, 0x02} // 0x66 f
  ,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 0x67 g
  ,{0x7f, 0x08, 0x04, 0x04, 0x78} // 0x68 h
  ,{0x00, 0x44, 0x7d, 0x40, 0x00} // 0x69 i
  ,{0x20, 0x40, 0x44, 0x3d, 0x00} // 0x6a j
  ,{0x7f, 0x10, 0x28, 0x44, 0x00} // 0x6b k
  ,{0x00, 0x41, 0x7f, 0x40, 0x00} // 0x6c l
  ,{0x7c, 0x04, 0x18, 0x04, 0x78} // 0x6d m
  ,{0x7c, 0x08, 0x04, 0x04, 0x78} // 0x6e n
  ,{0x38, 0x44, 0x44, 0x44, 0x38} // 0x6f o
  ,{0x7c, 0x14, 0x14, 0x14, 0x08} // 0x70 p
  ,{0x08, 0x14, 0x14, 0x18, 0x7c} // 0x71 q
  ,{0x7c, 0x08, 0x04, 0x04, 0x08} // 0x72 r
  ,{0x48, 0x54, 0x54, 0x54, 0x20} // 0x73 s
  ,{0x04, 0x3f, 0x44, 0x40, 0x20} // 0x74 t
  ,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 0x75 u
  ,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 0x76 v
  ,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 0x77 w
  ,{0x44, 0x28, 0x10, 0x28, 0x44} // 0x78 x
  ,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 0x79 y
  ,{0x44, 0x64, 0x54, 0x4c, 0x44} // 0x7a z
  ,{0x00, 0x08, 0x36, 0x41, 0x00} // 0x7b {
  ,{0x00, 0x00, 0x7f, 0x00, 0x00} // 0x7c |
  ,{0x00, 0x41, 0x36, 0x08, 0x00} // 0x7d }
  ,{0x10, 0x08, 0x08, 0x10, 0x08} // 0x7e ~
  ,{0x78, 0x46, 0x41, 0x46, 0x78} // 0x7f DEL
};

// char xkcdSandwich[504] = {
// 0xFF, 0x8D, 0x9F, 0x13, 0x13, 0xF3, 0x01, 0x01, 0xF9, 0xF9, 0x01, 0x81, 0xF9, 0xF9, 0x01, 0xF1,
// 0xF9, 0x09, 0x09, 0xFF, 0xFF, 0xF1, 0xF9, 0x09, 0x09, 0xF9, 0xF1, 0x01, 0x01, 0x01, 0x01, 0x01,
// 0xF9, 0xF9, 0x09, 0xF9, 0x09, 0xF9, 0xF1, 0x01, 0xC1, 0xE9, 0x29, 0x29, 0xF9, 0xF1, 0x01, 0xFF,
// 0xFF, 0x71, 0xD9, 0x01, 0x01, 0xF1, 0xF9, 0x29, 0x29, 0xB9, 0xB1, 0x01, 0x01, 0x01, 0xF1, 0xF1,
// 0x11, 0xF1, 0xF1, 0xF1, 0xE1, 0x01, 0xE1, 0xF1, 0x51, 0x51, 0x71, 0x61, 0x01, 0x01, 0xC1, 0xF1,
// 0x31, 0x31, 0xF1, 0xFF, 0xFF, 0x00, 0x01, 0x01, 0x01, 0x01, 0x60, 0xE0, 0xA0, 0x01, 0x01, 0x81,
// 0xE1, 0x61, 0x60, 0xC0, 0x01, 0xE1, 0xE1, 0x21, 0x21, 0xE0, 0xC1, 0x01, 0xC1, 0xE1, 0x20, 0x20,
// 0xFC, 0xFC, 0xE0, 0xE0, 0xC1, 0xE1, 0xE0, 0xC1, 0xE0, 0xE1, 0x01, 0xFC, 0xFC, 0x21, 0x21, 0xE1,
// 0xC1, 0xE5, 0xE4, 0x01, 0xC1, 0xE0, 0x20, 0x21, 0x20, 0x00, 0x01, 0xFD, 0xFD, 0x21, 0x20, 0xE0,
// 0x00, 0x00, 0x01, 0x01, 0xC0, 0x61, 0x31, 0x31, 0x21, 0x20, 0xC0, 0x81, 0x01, 0x01, 0x01, 0x00,
// 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x02,
// 0x03, 0x01, 0x00, 0x01, 0x03, 0xF2, 0x1A, 0x0B, 0x08, 0x0B, 0x1B, 0x10, 0x60, 0xE3, 0x03, 0x00,
// 0x01, 0x03, 0x02, 0x02, 0x03, 0x03, 0x00, 0x03, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x03,
// 0x03, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x00, 0x01, 0x03, 0x02, 0x02, 0x03, 0x01, 0x00, 0x03,
// 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3E, 0x63, 0x80, 0x80, 0x80, 0x80, 0x60, 0x3F, 0x07,
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00,
// 0x00, 0x00, 0x00, 0x00, 0xFE, 0x01, 0x01, 0x01, 0x02, 0x03, 0x3E, 0xE8, 0xF8, 0xF0, 0xD0, 0x90,
// 0x18, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x38, 0xFF,
// 0x0C, 0x38, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
// 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33,
// 0x5F, 0x8F, 0x84, 0x05, 0x07, 0x06, 0x0C, 0x0E, 0x0E, 0x0C, 0x14, 0x34, 0x68, 0x88, 0xD8, 0x70,
// 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x10, 0x10, 0x10, 0xF0, 0xE0, 0x00, 0xF0, 0xF0, 0x00, 0x80,
// 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x20, 0x38,
// 0x0E, 0x01, 0xC0, 0x3F, 0xE0, 0x00, 0x00, 0x03, 0x0E, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xB6, 0xED, 0xC0, 0xC0,
// 0xC0, 0xE0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xA1, 0xE1, 0xE1, 0xC1,
// 0xEF, 0xBB, 0x83, 0x86, 0x88, 0xB0, 0x80, 0x80, 0x80, 0x8F, 0x90, 0x90, 0x90, 0x9F, 0x8F, 0x80,
// 0x9F, 0x9F, 0x87, 0x8D, 0x98, 0x80, 0x8C, 0x9E, 0x92, 0x92, 0x9F, 0xC0, 0xC7, 0xFF, 0xB8, 0x8F,
// 0x80, 0x90, 0x90, 0xC0, 0xF0, 0x8E, 0x81, 0x80, 0x81, 0x8F, 0xB8, 0xE0, 0x80, 0x80, 0x80, 0x80,
// 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xFF,
// };

char err_face [504] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8,
0xFC, 0xFF, 0xDF, 0xAF, 0x55, 0x80, 0x55, 0x00, 0x55, 0x00, 0x55, 0x00, 0x55, 0x00, 0x55, 0x00,
0x55, 0x00, 0x55, 0x00, 0x55, 0x80, 0xD5, 0x80, 0xD5, 0xE0, 0xF5, 0x60, 0x75, 0x70, 0x75, 0x60,
0x75, 0xE0, 0xD5, 0x80, 0xD5, 0x00, 0x55, 0x00, 0x55, 0x00, 0x57, 0x07, 0x5E, 0x3C, 0x70, 0xF0,
0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x03, 0x5F, 0xFF, 0xFF, 0xFF, 0xD7, 0xEE, 0xD5, 0xE8, 0xD5, 0xA0, 0xD5, 0x80,
0xD5, 0xC0, 0xF5, 0xE0, 0xBD, 0xF8, 0xDF, 0xEE, 0x7F, 0x3B, 0x3F, 0x0F, 0x0F, 0x06, 0x06, 0x06,
0x06, 0x06, 0x0C, 0x0C, 0x38, 0x38, 0xF1, 0xC1, 0xC3, 0x07, 0x07, 0x3C, 0x3D, 0xF8, 0xF5, 0xC0,
0x55, 0x00, 0x55, 0x00, 0x55, 0x03, 0x57, 0x1E, 0x7C, 0xF0, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0xC7, 0xFF, 0xFD, 0x7A,
0xDD, 0xFE, 0xFF, 0x77, 0x7F, 0x3C, 0x7E, 0x3F, 0x3F, 0x3F, 0x7F, 0xFF, 0x80, 0x80, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0F, 0x8F, 0xC4, 0xE0, 0x7D, 0x3F, 0x1F, 0x00, 0x00, 0x00,
0x80, 0x80, 0xE1, 0xE7, 0x7F, 0x3E, 0x55, 0x00, 0x55, 0x00, 0x55, 0x00, 0x55, 0x00, 0x55, 0x01,
0x57, 0x0F, 0x5C, 0x78, 0x70, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE0, 0xF0, 0xBC, 0xDF, 0xEF,
0xF7, 0xFF, 0xFF, 0xFF, 0x47, 0x03, 0x01, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xE0, 0x00, 0x01,
0x07, 0x07, 0x0E, 0xCC, 0xCC, 0xFC, 0x7C, 0x3C, 0x1C, 0x0E, 0x07, 0x83, 0xC1, 0xE0, 0x70, 0x30,
0x78, 0x1C, 0x5C, 0x0F, 0x57, 0x03, 0xD5, 0xC0, 0xD5, 0xE0, 0x75, 0x30, 0x35, 0xB8, 0xDD, 0xF8,
0xFD, 0xF8, 0xFD, 0xB8, 0x35, 0x30, 0xF5, 0xC0, 0xD5, 0x03, 0x57, 0x0F, 0x5F, 0xBC, 0xF0, 0xF0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF,
0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xF0, 0xF0, 0xE1,
0xF1, 0xF0, 0x78, 0xB8, 0x5E, 0x2E, 0x57, 0x81, 0xD1, 0xE8, 0xF4, 0xB8, 0xFC, 0xBE, 0x77, 0xA3,
0x55, 0x80, 0xD5, 0xC0, 0xF5, 0x78, 0x3D, 0xBE, 0xFF, 0xE6, 0xF3, 0xF9, 0x1D, 0x0D, 0x07, 0x07,
0x0F, 0xF9, 0xF9, 0xF0, 0xF0, 0xB8, 0x19, 0x1F, 0xC6, 0xCE, 0xFB, 0xFB, 0x7F, 0xE8, 0xF5, 0xFE,
0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x07, 0x0F, 0x1F, 0x1F, 0x1F, 0x3B, 0x77, 0x7F, 0x7F, 0x6F, 0x7F, 0x7F,
0x7F, 0x3F, 0x3F, 0x3B, 0x1D, 0x1C, 0x1D, 0x1E, 0x1F, 0x0E, 0x1F, 0x0F, 0x1F, 0x3F, 0x7D, 0xEE,
0xFF, 0xFE, 0xF7, 0xEA, 0x7F, 0x7F, 0x7F, 0x3F, 0x1F, 0x1E, 0x7F, 0xE3, 0xC1, 0xE0, 0xF1, 0x73,
0x1F, 0x1E, 0x9F, 0xFB, 0xF3, 0x60, 0x70, 0xFC, 0xDD, 0xEF, 0xD7, 0xE3, 0xD7, 0xE1, 0xD5, 0xF8,
0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
};


uint8_t retry_count = 0;
uint8_t countLedToggle = 0;
unsigned long old_time = millis();
unsigned long check_PSI = millis();

uint8_t lineCount = 1;
char display_msg[72];
char line1_msg[13];
char line2_msg[13];

boolean new_msg = FALSE;
boolean led_update = FALSE;
boolean toggleLED = FALSE;
uint8_t led_brightness = 0;


void setup(void) {
    WiFi.on();
    RGB.brightness(10);
    pinMode(D7,OUTPUT);
 //   Spark.function("msg",message);
    Spark.function("led",ledBrightness);

    //For debugging
    Serial.begin(115200);
    Particle.subscribe("soc",processSoc,MY_DEVICES);

    ThingSpeak.begin(client);

    // Lets listen for the hook response
//    Spark.subscribe("hook-response/SGpsi", gotPsiData, MY_DEVICES);

    //Init the LCD
    LCDInit();
    LCDClear();
    LCDBitmap(err_face);
    gotoXY(0, 0); //for line 1
}


unsigned long pubTS	 = 0;


void loop(void) {
     if(millis() - old_time >= 2000){
        if(retry_count < 10){
            if(!WiFi.ready()){
                WiFi.connect();
                retry_count++;
                Serial.println("!WiFi.ready()");
            }
            else if (!Spark.connected()){
                Spark.connect();
                retry_count++;
                Serial.println("!Spark.connected()");
            }
        }
        else{
            WiFi.off();
            retry_count = 0;
            WiFi.on();
        }
        old_time = millis();
    }


    if(new_msg == TRUE){
        gotoXY(0, 0); //for line 1
        LCDString("2G:");
        LCDString(line1_msg);
        gotoXY(0, 49); //for line 2
        LCDString("3G:");
        LCDString(line2_msg);
        new_msg = FALSE;
        toggleLED = TRUE;

        if(lineCount == 1)
            ThingSpeak.setField(2,line1_msg);
        else
		    ThingSpeak.setField(3,line2_msg);

		// Then you write the fields that you've set all at once.
		Serial.println(ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey));
		Serial.println(ThingSpeak.getLastReadStatus());
    }
    if(led_update == TRUE){
        //digitalWrite(PIN_LED,led_status);
        analogWrite(PIN_LED, led_brightness);
        led_update = FALSE;
    }
    if(toggleLED == TRUE){
        if(countLedToggle >= 200){
            countLedToggle = 0;
            digitalWrite(PIN_LED,LOW);
            toggleLED = FALSE;
        }
        else{
            delay(10);
             if(countLedToggle % 3)
                 digitalWrite(PIN_LED, HIGH);
            else
                digitalWrite(PIN_LED, LOW);
            countLedToggle++;
        }

    }
}

/*
Return status code
-2 | No message
-1 | Message too long
 1 | success

*/
int message(String msg){
  if(msg.length() == 0)
    return -2;
  else if (msg.length() <= 108)
  {
    msg.toCharArray(display_msg, msg.length()+1);
    new_msg = TRUE;
    return 1;
  }
  else return -1;
}


// int toggle_led(String msg){
//   if(msg == "on"){
//     led_status = HIGH;
//     led_update = TRUE;
//     return 1;
//   }
//   else if (msg == "off")
//   {
//     led_status = LOW;
//     led_update = TRUE;
//     return 0;
//   }
//   else return -1;
// }


int ledBrightness(String msg){
  if(msg.toInt() > 255 || msg.toInt() < 0 || msg == ""){
    return -1;
  }
  else {
    led_brightness = msg.toInt();
    led_update = TRUE;
    return 1;
  }
}


// This function will get called when PSI data comes in
void gotPsiData(const char *name, const char *data) {
    String str = String(data);
    String idStr = tryExtractString(str, "<id>", "</id>");
    String psiStr = tryExtractString(str, "<reading type=\"PM25_RGN_1HR\" value=\"", "\"/>");

    if (idStr != NULL) {
        Serial.println("ID: " + idStr);
    }

    if (psiStr != NULL) {
        Serial.println("psi: " + psiStr);
    }

}

// Returns any text found between a start and end string inside 'str'
// example: startfooend  -> returns foo
String tryExtractString(String str, const char* start, const char* end) {
    if (str == NULL) {
        return NULL;
    }

    int idx = str.indexOf(start);
    if (idx < 0) {
        return NULL;
    }

    int endIdx = str.indexOf(end);
    if (endIdx < 0) {
        return NULL;
    }

    return str.substring(idx + strlen(start), endIdx);
}


void gotoXY(int x, int y) {
  LCDWrite(0, 0x80 | x);  // Column.
  LCDWrite(0, 0x40 | y);  // Row.  ?
}

//This takes a large array of bits and sends them to the LCD
void LCDBitmap(char my_array[]){
  for (int index = 0 ; index < (LCD_X * LCD_Y / 8) ; index++)
    LCDWrite(LCD_DATA, my_array[index]);
}

//This function takes in a character, looks it up in the font table/array
//And writes it to the screen
//Each character is 8 bits tall and 5 bits wide. We pad one blank column of
//pixels on each side of the character for readability.
void LCDCharacter(char character) {
  LCDWrite(LCD_DATA, 0x00); //Blank vertical line padding
  Serial.print(character);
  for (int index = 0 ; index < 5 ; index++){
    LCDWrite(LCD_DATA, ASCII[character - 0x20][index]);
    //0x20 is the ASCII character for Space (' '). The font table starts with this character
  }
  LCDWrite(LCD_DATA, 0x00); //Blank vertical line padding
}

//Given a string of characters, one by one is passed to the LCD
void LCDString(char *characters) {
  while (*characters)
    LCDCharacter(*characters++);
}

//Clears the LCD by writing zeros to the entire screen
void LCDClear(void) {
  for (int index = 0 ; index < (LCD_X * LCD_Y / 8) ; index++)
    LCDWrite(LCD_DATA, 0x00);

  gotoXY(0, 0); //After we clear the display, return to the home position
}

//This sends the magical commands to the PCD8544
void LCDInit(void) {
  //Configure control pins
    pinMode(PIN_SCE, OUTPUT);
    pinMode(PIN_RESET, OUTPUT);
    pinMode(PIN_DC, OUTPUT);
    pinMode(PIN_SDIN, OUTPUT);
    pinMode(PIN_SCLK, OUTPUT);
    pinMode(PIN_LED, OUTPUT);
    pinMode(PIN_LED, OUTPUT);
    pinMode(PIN_POWER, OUTPUT);
    //Turn on LCD
    digitalWrite(PIN_POWER,HIGH);
    delay(100);

    //Reset the LCD to a known state
    digitalWrite(PIN_RESET, LOW);
    digitalWrite(PIN_RESET, HIGH);

    //Turn off LED by default
    digitalWrite(PIN_LED,LOW);



  LCDWrite(LCD_COMMAND, 0x21); //Tell LCD that extended commands follow
  LCDWrite(LCD_COMMAND, 0xB1); //Set LCD Vop (Contrast): Try 0xB1(good @ 3.3V) or 0xBF if your display is too dark
  LCDWrite(LCD_COMMAND, 0x04); //Set Temp coefficent
  LCDWrite(LCD_COMMAND, 0x14); //LCD bias mode 1:48: Try 0x13 or 0x14

  LCDWrite(LCD_COMMAND, 0x20); //We must send 0x20 before modifying the display control mode
  LCDWrite(LCD_COMMAND, 0x0C); //Set display control, normal mode. 0x0D for inverse
}


//There are two memory banks in the LCD, data/RAM and commands. This
//function sets the DC pin high or low depending, and then sends
//the data byte
void LCDWrite(byte data_or_command, char data) {
  digitalWrite(PIN_DC, data_or_command); //Tell the LCD that we are writing either to data or a command

  //Send the data
  digitalWrite(PIN_SCE, LOW);
  shiftOut(PIN_SDIN, PIN_SCLK, MSBFIRST, data);
  digitalWrite(PIN_SCE, HIGH);
}

// This function will get called when new electron SOC data comes in
void processSoc(const char *name, const char *data) {
    if(String(name) == "soc-2g"){
        strncpy(line1_msg, data ,12);
        lineCount = 1;
    }
    else{
        strncpy(line2_msg, data ,12);
        lineCount = 2;
    }
    new_msg = TRUE;
    toggleLED = TRUE;
}
